
C language doesnt support strings out of the box ==> an array of single characters
There are a number of C extension libraries that DO give you strings.

C knows to stop when it sees '\0' ==> sentinel character. We have to allow for an extra character in the array

LOVELY: The index is an offset: it's a measure of how far the character is from the first character. That's why we start from 0
It's better for the computer to calculate memory locations

Single quotes are used for individual characters, but double quotes are always used for strings

Difference between string literals and character arrays: literals are constants. if I try to change individual characters once created gcc will throw a bus error
They are stored in memory in a different way

block statements are groups of commands surrounded by braces.

The AND (&&) operator is efficient: if the first condition is false, then the computer wont bother evaluating the second condition

With OR (||) if the first condition is true, the computer wont bother evaluating the second condition.

In C boolean values are represented by numbers. The number 0 is false. Anything that is not equal to 0 is treated as true.

The & and | operators will ALWAYS EVALUATE both conditions, but && and || can often skip the second condition.

[23] Be the compiler
A- compiles. prints 'Small card'
B- compiles. prints nothing
C- compiles prints Ace!
D- doesnt compile

........
Switch statement can test for multiple values of a single variable

No, you cant use a switch statement to check a string of characters or any kind of array. The switch statement will only check a single value.

The main() function has an int return type so you should include a return statement when you get to the end. But if you leave the return statement out, the code will still compile - though you may get a warning from the compiler. A C99 compiler will insert a RETURN statement for you if you forget. Use -std=99 to compile to the C99 standard.

GCC: gnu compiler collection


SNAFU is an acronym that is widely used to stand for the sarcastic expression Situation Normal: All Fucked Up

Pointers is just the address of a piece of data in memory.
They are a form of indirection.


IF YOU WANT TO FIND OUT THE MEMORY ADDRESS OF THE VARIABLE YOU CAN USE THE $ OPERATOR:
printf("x is stored at %p\n", &x);

%p is used to format addresses.

evega@Esthers-MacBook-Pro headFirstC $ gcc memory.c -o memory && ./memory
x is stored at 0x7ffee3862a28
y is stored at 0x10c39e018

C sends arguments as VALUES
How can you ever write a function that updates a variable? ==> it's easy, use pointers.
Pass the address of the variable

Why are local variables stored in the stack and globals stored somewhere else: Local and global ariables are used differently. You will only ever get one copy of a global variable, but if you write a function that calls itself, you might get very many instances of the same local variable.
Pointers make it easier to share memory

int *address_of_x = &x; (this is a pointer for an address that stores an int)
int value_stored = *address_of_x; (when you have the memory address you want to read the data that is stored there using the * operator)

The * and & operators are opposites. The & operator takes a piece of data and tells you where it's stored. The * operator takes and address and tells you what's stored there.
Because pointers are sometimes called references, the * operator is said to DEREFERENCE a pointer.

To change the content of an address 
*address_of_x = 99;


variables are allocated storage in memory
local variables live in the stack
global variables live in the globals section
pointers are just variables that store memory addresses
The & operator finds the address of a variable
The * operator can read the contents of a memory address
The * operator can also set the contents of a memory address.

Pointers are actual numeric addresses in teh process memory

sizeof operator returned the size of a pointer to a string. On 32 bit operating system a pointer takes 4 bytes of memory and on 64 bit operative systems a pointer takes 8 bytes


....
An array variable can be used as a pointer
The array variable points to the first element in the array
If you declare an array argument to a function it will be treated as a pointer
The sizeof operator returns the space taken by a piede of data
you can also call size for a cata such as sizeof(int)
sizeof(apointer) returns 4 on 32 bit operating systems and 8 on 64-bit.

sizeof is not a function, is an operator
An operator is compiled to a sequence of instructions by the compiler.But if the code calls a function it has to jump to a separate piede of code

A pointer variable is just a variable storing a number living in memory

An array variable can be used as a pointer to the first element in an array.

WOW :))))))) DODGY
doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]


Array variables can be used as pointers, but are not quite the same
sizeof is different for array and pointer variables
Array variables cant point to anything else
passing an array variable to a pointer decays it
Arrays start at zero because of pointer arithmetic
pointer variables have types so they can adjust pointer arithmetic


scanf("%39s", name); // scanf will read up to 39 characters plus the string terminator \0

scanf("%19s %i", first_name, age);

if you just use %s in scanf, there can be a problem if someone gets a little type-happy ==> Segmentation fault
If the scanf writes data beyong the end of the space allocated to the food array.
-------------------------------SCANF CAN CAUSE BUFFER OVERFLOWS--------------------------------
You might get lucky and the data will simply be stored and not cause any problems
But it's very likely that buffer overflow will cause bugs. It might be called a segmentation fault or an abor trap, but whatever the error message that appears, the result will be a crash.

FGETS as an alternative to SCANF
size is mandatory and INCLUDES the final \0
sizeof wont work if you pass a pointer. remember to give an explicit length then
gets has no limit at all. has been around for a long time but shouldnt be used

Scanf reads a string with %s and stops as soon as it hits a space. So if you want to enter more than one word you either have to call it more than once or use some fancy regular expression.

==> if you need to enter structured data with several fields ==> use SCANF
==> if you are entering a single unstructure string ==> fgets is the way to go

STRING LITERALS CAN NEVER BE UPDATED
A variable that points to a string literal cannot be used to change the contents of the string:
char *cards = "JQK"
but if you create an array from a string literal, then you can modify it:
char cards[] = "JQK"

STRINGS are loaded into the constants memory block. This section is read only. And *cards then a cards variable would be created in the stack

IF YOU ARE GOINT TO CHANGE A STRING MAKE A COPY
- what if cards is being declared as a function argument, it means that cards is a pointer.
=== void stack_deck(char cards[]) == void stack_deck(char *cards)

Best practices: never write code that sets a simple char pointer to a string literal value (char *s = "some string")
Trying to modify this would give you a headache.
Instead, if you set a pointer to a literal always make sure you use the CONST keyword, that way the compiler will complain beforehand
const char *s = "some things"

If you see a * in a variable declaration it means the variable will be a pointer
String literals are stored in read-only memory
If you want to modify a String you need to make a copy in a new array
You can declare a char pointer as const char* to prevent the code from using it to modify a string

STACK
HEAP
GLOBAL
CONSTANTS
CODE


STACK VS HEAP

&X returns the address of x
&x is called a pointer to x

...............................2.5 strings
string.h is part of the C standard library dedicated to string manipulation

strstr() ==> search within strings

Chances are you wont want to use the whole of the standard library at once, so the library is broken up into several sections and each one has a header file.

== stdio.h header file lets you use the standard input/output functions like printf and scanf
== stdlib.h ????
== string.h 

strchr() ==> find a char within a string
strcomp() ==> compare
strstr() ==> find a string within a string
strcpy() ==> copy
strlen() ==> find length
strcat() ==> concatenate two strings

	// strstr will search for the second string in the first string
	// returns 0 if no found
	strstr("dysfunctional", "fun");

// what happens when you read after the \0 in one of this strings?


man strstr()

https://stackoverflow.com/questions/21318269/bug-in-jukebox-code-head-first-c
The problem is that fgets stores the newline in the destination string. So your strstr needs to find "town\n". One solution would be to trim search_for after  fgets to get rid of the newline.

strstr(a,b) will return the address of string b in string a





